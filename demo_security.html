<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Check Security Demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .log-area {
            background-color: #f8f9fa;
            height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 0.75rem;
            font-family: monospace;
            font-size: 0.875rem;
        }
        .security-feature {
            background-color: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 1rem;
            margin: 1rem 0;
        }
        .log-entry {
            margin-bottom: 0.5rem;
            padding: 0.25rem 0;
        }
        .log-error {
            color: #dc3545;
        }
        .log-warning {
            color: #fd7e14;
        }
        .log-success {
            color: #198754;
        }
        .log-info {
            color: #0dcaf0;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <div class="row">
            <div class="col-md-8 mx-auto">
                <h1 class="text-center mb-4">이메일 체크 보안 데모</h1>
                
                <div class="security-feature">
                    <h5>🔒 구현된 보안 조치</h5>
                    <ul class="mb-0">
                        <li><strong>Rate Limiting:</strong> IP별 5분간 5회 제한</li>
                        <li><strong>CAPTCHA 검증:</strong> 자동화 방지</li>
                        <li><strong>회원가입 토큰:</strong> 정당한 플로우에서만 접근</li>
                        <li><strong>보안 로깅:</strong> 모든 시도 추적</li>
                    </ul>
                </div>

                <!-- Step 1: Generate Signup Token -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h5>1단계: 회원가입 토큰 생성</h5>
                    </div>
                    <div class="card-body">
                        <p>먼저 회원가입 플로우를 시작하기 위해 토큰을 생성해야 합니다.</p>
                        <button id="generateTokenBtn" class="btn btn-primary">토큰 생성</button>
                        <div id="tokenInfo" class="mt-3" style="display: none;">
                            <div class="alert alert-success">
                                <strong>토큰 생성 성공!</strong><br>
                                토큰: <code id="signupToken"></code><br>
                                남은 이메일 체크 횟수: <span id="remainingChecks"></span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Email Check -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h5>2단계: 이메일 중복 확인</h5>
                    </div>
                    <div class="card-body">
                        <form id="emailCheckForm">
                            <div class="mb-3">
                                <label for="email" class="form-label">이메일 주소</label>
                                <input type="email" class="form-control" id="email" required>
                            </div>
                            
                            <!-- CAPTCHA Section (initially hidden) -->
                            <div id="captchaSection" class="mb-3" style="display: none;">
                                <label class="form-label">보안 검증</label>
                                <div class="alert alert-warning">
                                    <strong>CAPTCHA 필요:</strong> <span id="captchaQuestion"></span>
                                </div>
                                <input type="hidden" id="captchaId">
                                <input type="number" class="form-control" id="captchaAnswer" placeholder="답을 입력하세요">
                            </div>
                            
                            <button type="submit" class="btn btn-success" id="checkEmailBtn">이메일 확인</button>
                            <button type="button" class="btn btn-warning" id="simulateAttackBtn">공격 시뮬레이션</button>
                        </form>
                    </div>
                </div>

                <!-- Results -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h5>결과 및 로그</h5>
                    </div>
                    <div class="card-body">
                        <div id="resultArea" class="mb-3"></div>
                        <div class="log-area" id="logArea"></div>
                        <button class="btn btn-secondary btn-sm mt-2" onclick="clearLogs()">로그 지우기</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let signupToken = '';
        let currentCaptchaId = '';
        let attackAttempts = 0;

        // Utility functions
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            
            const logArea = document.getElementById('logArea');
            logArea.appendChild(logEntry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function showResult(message, type = 'info') {
            const resultArea = document.getElementById('resultArea');
            resultArea.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
        }

        function clearLogs() {
            document.getElementById('logArea').innerHTML = '';
            document.getElementById('resultArea').innerHTML = '';
        }

        // Step 1: Generate signup token
        document.getElementById('generateTokenBtn').addEventListener('click', async function() {
            try {
                log('회원가입 토큰 생성 요청...', 'info');
                
                // Simulate API call
                const response = await simulateTokenGeneration();
                
                if (response.success) {
                    signupToken = response.signup_token;
                    document.getElementById('signupToken').textContent = signupToken.substring(0, 16) + '...';
                    document.getElementById('remainingChecks').textContent = response.email_checks_allowed;
                    document.getElementById('tokenInfo').style.display = 'block';
                    
                    log('회원가입 토큰 생성 성공', 'success');
                    showResult('회원가입 토큰이 생성되었습니다. 이제 이메일 확인을 진행할 수 있습니다.', 'success');
                } else {
                    log('토큰 생성 실패: ' + response.message, 'error');
                    showResult('토큰 생성 실패: ' + response.message, 'danger');
                }
            } catch (error) {
                log('토큰 생성 오류: ' + error.message, 'error');
                showResult('토큰 생성 중 오류가 발생했습니다.', 'danger');
            }
        });

        // Step 2: Email check
        document.getElementById('emailCheckForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            if (!signupToken) {
                showResult('먼저 회원가입 토큰을 생성해주세요.', 'warning');
                return;
            }
            
            const email = document.getElementById('email').value;
            const captchaAnswer = document.getElementById('captchaAnswer').value;
            
            await performEmailCheck(email, captchaAnswer);
        });

        // Attack simulation
        document.getElementById('simulateAttackBtn').addEventListener('click', async function() {
            attackAttempts++;
            log(`공격 시뮬레이션 시작 (시도 #${attackAttempts})`, 'warning');
            
            const testEmails = [
                'admin@example.com',
                'user@example.com', 
                'test@example.com',
                'noreply@example.com',
                'contact@example.com'
            ];
            
            for (let i = 0; i < testEmails.length; i++) {
                log(`대량 이메일 체크 시도: ${testEmails[i]}`, 'warning');
                
                // Simulate rapid requests without proper token
                const response = await simulateEmailCheck(testEmails[i], '', '', '');
                
                if (response.status === 429) {
                    log('Rate Limit 발동! 공격 차단됨', 'error');
                    showResult('🚫 공격이 탐지되어 차단되었습니다. Rate Limiting이 정상 작동합니다.', 'danger');
                    break;
                } else if (response.status === 401) {
                    log('인증 실패! 토큰 없이 접근 차단됨', 'error');
                    showResult('🚫 인증되지 않은 접근이 차단되었습니다.', 'danger');
                    break;
                }
                
                // Delay between requests
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        });

        // Simulate email check
        async function performEmailCheck(email, captchaAnswer) {
            try {
                log(`이메일 확인 요청: ${email}`, 'info');
                
                const response = await simulateEmailCheck(email, signupToken, currentCaptchaId, captchaAnswer);
                
                if (response.status === 200) {
                    const data = response.data;
                    log(`이메일 확인 완료: ${data.exists ? '사용 중' : '사용 가능'}`, 'success');
                    showResult(`✅ ${data.message}<br>남은 요청 수: ${data.rate_limit.remaining}`, 'success');
                    
                    // Hide CAPTCHA on success
                    document.getElementById('captchaSection').style.display = 'none';
                    
                } else if (response.status === 422 && response.data.captcha_required) {
                    log('CAPTCHA 검증 필요', 'warning');
                    showCaptcha(response.data.captcha);
                    
                } else if (response.status === 429) {
                    log('Rate Limit 초과', 'error');
                    showResult(`⚠️ ${response.data.message}<br>재시도 가능 시간: ${new Date(response.data.rate_limit.reset_time * 1000).toLocaleTimeString()}`, 'warning');
                    
                } else {
                    log(`요청 실패 (${response.status}): ${response.data.message}`, 'error');
                    showResult(`❌ ${response.data.message}`, 'danger');
                }
                
            } catch (error) {
                log('이메일 확인 오류: ' + error.message, 'error');
                showResult('이메일 확인 중 오류가 발생했습니다.', 'danger');
            }
        }

        function showCaptcha(captcha) {
            document.getElementById('captchaQuestion').textContent = captcha.question;
            document.getElementById('captchaId').value = captcha.challenge_id;
            currentCaptchaId = captcha.challenge_id;
            document.getElementById('captchaSection').style.display = 'block';
            document.getElementById('captchaAnswer').value = '';
            document.getElementById('captchaAnswer').focus();
            
            showResult('보안을 위해 CAPTCHA 인증이 필요합니다.', 'warning');
        }

        // Simulation functions (실제 API 대신 보안 로직 시뮬레이션)
        const simulationState = {
            requests: [],
            tokens: {},
            captchas: {}
        };

        function simulateTokenGeneration() {
            const now = Date.now();
            const recentRequests = simulationState.requests.filter(req => 
                req.action === 'token_gen' && (now - req.timestamp) < 600000 // 10분
            );
            
            if (recentRequests.length >= 3) {
                return Promise.resolve({
                    success: false,
                    message: '토큰 생성 요청이 너무 많습니다. 잠시 후 다시 시도해주세요.'
                });
            }
            
            simulationState.requests.push({
                action: 'token_gen',
                timestamp: now
            });
            
            const token = 'signup_' + Math.random().toString(36).substring(2, 15);
            simulationState.tokens[token] = {
                created_at: now,
                email_checks_count: 0
            };
            
            return Promise.resolve({
                success: true,
                signup_token: token,
                expires_in: 1800,
                email_checks_allowed: 5
            });
        }

        function simulateEmailCheck(email, signupToken, captchaId, captchaAnswer) {
            const now = Date.now();
            
            // Rate limiting check
            const recentRequests = simulationState.requests.filter(req => 
                req.action === 'email_check' && (now - req.timestamp) < 300000 // 5분
            );
            
            if (recentRequests.length >= 5) {
                return Promise.resolve({
                    status: 429,
                    data: {
                        success: false,
                        message: '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.',
                        exists: false,
                        rate_limit: {
                            reset_time: Math.floor((recentRequests[0].timestamp + 300000) / 1000),
                            remaining: 0
                        }
                    }
                });
            }
            
            // Token validation
            if (!signupToken || !simulationState.tokens[signupToken]) {
                return Promise.resolve({
                    status: 401,
                    data: {
                        success: false,
                        message: '이 기능은 회원가입 과정에서만 사용할 수 있습니다.',
                        exists: false,
                        error_code: 'AUTH_REQUIRED'
                    }
                });
            }
            
            const tokenData = simulationState.tokens[signupToken];
            
            // Token expiry check
            if (now - tokenData.created_at > 1800000) { // 30분
                delete simulationState.tokens[signupToken];
                return Promise.resolve({
                    status: 401,
                    data: {
                        success: false,
                        message: '회원가입 세션이 만료되었습니다. 다시 시작해주세요.',
                        exists: false,
                        error_code: 'INVALID_TOKEN'
                    }
                });
            }
            
            // Email check limit
            if (tokenData.email_checks_count >= 5) {
                return Promise.resolve({
                    status: 401,
                    data: {
                        success: false,
                        message: '이메일 확인 횟수 제한에 도달했습니다.',
                        exists: false,
                        error_code: 'LIMIT_EXCEEDED'
                    }
                });
            }
            
            // CAPTCHA requirement (always for demo)
            if (!captchaId || !captchaAnswer) {
                const captcha = generateCaptcha();
                return Promise.resolve({
                    status: 422,
                    data: {
                        success: false,
                        message: '보안을 위해 인증이 필요합니다.',
                        exists: false,
                        captcha_required: true,
                        captcha: captcha,
                        error_code: 'CAPTCHA_REQUIRED'
                    }
                });
            }
            
            // CAPTCHA validation
            if (!simulationState.captchas[captchaId] || 
                simulationState.captchas[captchaId].answer !== parseInt(captchaAnswer)) {
                const newCaptcha = generateCaptcha();
                return Promise.resolve({
                    status: 422,
                    data: {
                        success: false,
                        message: '인증에 실패했습니다. 다시 시도해주세요.',
                        exists: false,
                        captcha_required: true,
                        captcha: newCaptcha,
                        error_code: 'CAPTCHA_FAILED'
                    }
                });
            }
            
            // Success case
            simulationState.requests.push({
                action: 'email_check',
                timestamp: now
            });
            
            tokenData.email_checks_count++;
            delete simulationState.captchas[captchaId];
            
            const exists = Math.random() > 0.5; // 랜덤하게 존재/비존재 결정
            
            return Promise.resolve({
                status: 200,
                data: {
                    success: true,
                    exists: exists,
                    message: exists ? '이미 사용 중인 이메일입니다.' : '사용 가능한 이메일입니다.',
                    rate_limit: {
                        remaining: 5 - recentRequests.length - 1,
                        reset_time: Math.floor((now + 300000) / 1000)
                    },
                    signup_flow: {
                        remaining_checks: 5 - tokenData.email_checks_count
                    }
                }
            });
        }

        function generateCaptcha() {
            const num1 = Math.floor(Math.random() * 10) + 1;
            const num2 = Math.floor(Math.random() * 10) + 1;
            const operations = ['+', '-', '*'];
            const operation = operations[Math.floor(Math.random() * operations.length)];
            
            let answer;
            switch (operation) {
                case '+':
                    answer = num1 + num2;
                    break;
                case '-':
                    if (num1 < num2) [num1, num2] = [num2, num1];
                    answer = num1 - num2;
                    break;
                case '*':
                    answer = num1 * num2;
                    break;
            }
            
            const challengeId = 'captcha_' + Math.random().toString(36).substring(2, 15);
            simulationState.captchas[challengeId] = {
                answer: answer,
                created_at: Date.now()
            };
            
            return {
                question: `${num1} ${operation} ${num2} = ?`,
                challenge_id: challengeId
            };
        }

        // Initial log
        log('보안 데모 페이지가 로드되었습니다.', 'info');
        log('이 페이지는 이메일 체크 보안 조치를 시연합니다.', 'info');
    </script>
</body>
</html>